<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Urim Yang's personal blog about computer science, Rust programming, and networking.">
        <link rel="icon" href="/lime_icon.png"/>
        <title>Urim Yang's Blog</title>

        <!-- MathJax CDN -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

        <script>
            MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']], // 인라인 수식 설정
                displayMath: [['$$', '$$'], ['\\[', '\\]']] // 블록 수식 설정
              }
            };
          </script>
          <script async src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
          <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
    
            body {
                font-family: 'Arial', sans-serif;
                line-height: 1.6;
                background: #f8f8f8;
                padding: 2rem;
                scroll-behavior: smooth;
            }
    
            .container {
                max-width: 1200px;
                margin: 0 auto;
            }
    
            .section-block {
                background: white;
                border-radius: 15px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.05);
                padding: 2rem;
                margin-bottom: 1.5rem;
                transition: transform 0.3s ease, box-shadow 0.3s ease;
            }

            /* 호버링 효과 추가 */
            .section-block:hover {
                transform: translateY(-5px);
                box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            }

            /* Text Section에 특별한 패딩 추가 */
            .text-content {
                padding: 0 2rem;
                max-width: 800px;
                margin: 0 auto;
                text-align: justify;
            }

            /* 첫 줄(제목)과 마지막 줄 왼쪽 정렬 */
            .text-content p:first-child,
            .text-content p:last-child {
                text-align: left;
            }
    
            /* Content Styling */
            /* Lists */
            .section-block ul,
            .section-block ol {
                padding-left: 2rem;
                margin: 1rem 0;
            }

            .section-block ul ul,
            .section-block ol ol,
            .section-block ul ol,
            .section-block ol ul {
                margin: 0.5rem 0;
            }

            /* Inline Code */
            code:not(pre code) {
                background-color: #f5f5f5;
                padding: 0.2em 0.4em;
                border-radius: 3px;
                font-family: monospace;
            }

            /* Blockquote */
            blockquote {
                border-left: 4px solid #32CD32;
                padding-left: 1rem;
                margin: 1rem 0;
                color: #666;
                background-color: #f9f9f9;
                padding: 1rem;
            }

            /* Tables */
            table {
                width: 100%;
                border-collapse: collapse;
                margin: 1rem auto;
                text-align: center;
            }

            th, td {
                border: 1px solid #ddd;
                padding: 0.8rem;
            }

            th {
                background-color: #f5f5f5;
            }

            /* Images */
            img:not(.profile-image) {
                display: block;
                max-width: 100%;
                margin: 1rem auto;
                border-radius: 5px;
            }

            /* Code Blocks */
            pre {
                background-color: #f5f5f5;
                padding: 1rem;
                border-radius: 5px;
                overflow-x: auto;
                margin: 1rem 0;
            }

            pre code {
                font-family: monospace;
                display: block;
                line-height: 1.5;
            }

            .animation-section {
                padding: 1.5rem;
                cursor: pointer;
            }
    
            .communication-container {
                position: relative;
                width: 500px;
                height: 100px;
                margin: 0 auto;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
    
            .object {
                width: 50px;
                height: 50px;
                background: #32CD32;
                border-radius: 50%;
                position: relative;
            }
    
            .object::after {
                content: '';
                position: absolute;
                top: -5px;
                left: -5px;
                right: -5px;
                bottom: -5px;
                border: 2px solid #32CD32;
                border-radius: 50%;
                opacity: 0;
                animation: pulse 2s infinite;
            }
    
            @keyframes pulse {
                0% { transform: scale(1); opacity: 0.8; }
                100% { transform: scale(1.5); opacity: 0; }
            }
    
            .signal {
                position: absolute;
                height: 2px;
                background: #32CD32;
                top: 50%;
                opacity: 0;
            }
    
            .syn { width: 40%; left: 20%; animation: sendSignal 3s infinite; }
            .syn-ack { width: 40%; right: 20%; animation: sendSignal 3s infinite 1s; }
            .ack { width: 60%; left: 20%; animation: sendSignal 3s infinite 2s; }
    
            @keyframes sendSignal {
                0% { transform: scaleX(0); opacity: 0; }
                20% { transform: scaleX(1); opacity: 1; }
                40% { transform: scaleX(1); opacity: 1; }
                60% { transform: scaleX(0); opacity: 0; }
                100% { transform: scaleX(0); opacity: 0; }
            }
    
            .site-title {
                text-align: center;
                font-size: 1.8rem;
                margin-top: 1rem;
                color: #333;
            }
    
            .profile-section {
                display: flex;
                align-items: center;
                gap: 1.5rem;
                padding: 1rem;
                max-width: 800px;
                margin: 0 auto;
                cursor: pointer;
            }
    
            .profile-image {
                width: 90px;
                height: 90px;
                border-radius: 50%;
                object-fit: cover;
                border: 3px solid #32CD32;
                flex-shrink: 0;
            }
    
            .profile-info {
                flex: 1;
                text-align: left;
            }
    
            .profile-name {
                font-size: 1.4rem;
                color: #333;
                margin-bottom: 0.3rem;
            }
    
            .profile-status {
                font-size: 0.95rem;
                color: #666;
                font-style: italic;
                line-height: 1.4;
            }
    
            .footer {
                text-align: center;
                padding: 1.5rem;
                color: #666;
                font-size: 0.9rem;
            }
    
            .footer a {
                color: #32CD32;
                text-decoration: none;
            }
    
            /* 반응형 디자인 */
            @media (max-width: 768px) {
                body {
                    padding: 1rem;
                }
    
                .section-block {
                    padding: 1.25rem;
                }

                .text-content {
                    padding: 0 1rem;
                }
    
                .communication-container {
                    width: 300px;
                    height: 70px;
                }
    
                .object {
                    width: 35px;
                    height: 35px;
                }
    
                .site-title {
                    font-size: 1.4rem;
                }
            }
    
            @media (max-width: 600px) {
                .profile-section {
                    flex-direction: column;
                    text-align: center;
                    gap: 0.8rem;
                    padding: 0.8rem;
                }
    
                .profile-info {
                    text-align: center;
                }
    
                .profile-image {
                    width: 75px;
                    height: 75px;
                }

                .text-content {
                    padding: 0 0.8rem;
                }
            }
    
            @media (max-width: 480px) {
                .communication-container {
                    width: 220px;
                    height: 50px;
                }
    
                .object {
                    width: 25px;
                    height: 25px;
                }
    
                .site-title {
                    font-size: 1.2rem;
                }
            }

            /* 플로팅 Top 버튼 스타일 */
            .floating-top-button {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 40px;
                height: 40px;
                background-color: #32CD32;
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            }

            .floating-top-button.visible {
                opacity: 1;
                visibility: visible;
            }

            .floating-top-button:hover {
                background-color: #28a428;
                transform: translateY(-3px);
            }
        </style>
    </head>
<body>
    <div class="container">
        <!-- Animation Section -->
        <a href="/" style="text-decoration: none; color: inherit;">
            <div class="section-block animation-section">
                <div class="communication-container">
                    <div class="object"></div>
                    <div class="object"></div>
                    <div class="signal syn"></div>
                    <div class="signal syn-ack"></div>
                    <div class="signal ack"></div>
                </div>
                <h1 class="site-title">Initiate, Acknowledge, Establish</h1>
            </div>
        </a>

        <!-- Profile Section -->
        <a href="mailto:email@com" style="text-decoration: none; color: inherit;">
            <div class="section-block">
                <div class="profile-section">
                    <img src="/profile.jpg" alt="Profile Image" class="profile-image">
                    <div class="profile-info">
                        <h2 class="profile-name">Urim Yang</h2>
                        <p class="profile-status">A Trailblazer Exploring Unknown Computer Network Worlds</p>
                    </div>
                </div>
            </div>
        </a>

        <!-- Text Section -->
        <div class="section-block">
            <div class="text-content" id="textContent">
                <h1>1.5 프로토콜 계층과 서비스 모델</h1>
<hr />
<p>인터넷을 구성하는 많은 요소(다양한 애플리케이션과 프로토콜, 여러 가지 종단 시스템과 종단 시스템과의 연결, 라우터, 다양한 링크 레벨의 매체)가 있음을 보았다. 상당히 복잡한 구조를 가짐에도 네트워크를 어떻게 조직하는지, 그것에 대한 논의가 왜 가능한지 살펴볼 것이다.</p>
<h2>1.5.1 계층구조</h2>
<hr />
<p>다음 시나리오를 생각해보자.</p>
<p><img src="../Figure_1/Figure_1.21.png" alt="그림 1.21 항공 여행: 과정들" /></p>
<blockquote>
<p>누군가 우리에게 항공 시스템을 설명해달라고 요청한다고 상상해보자. 티켓 에이전트, 수하물 검색대, 탑승구 요원, 조종사, 비행기, 관제소 그리고 비행기를 라우팅하는 전 세계 시스템을 가진 복잡한 시스템을 설명하기 위해 우리는 그 구조를 어떻게 찾을 것인가? 이 시스템을 설명하는 한 방법은 우리가 비행기를 탈 때 취하는 일련의 행동을 설명하는 것이다. 비행기 티켓을 사고, 가방을 검사받고, 탑승구로 가고, 비행기에 타면, 비행기는 이륙하고 목적지로 향한다. 비행기가 착륙한 후, 탑승구를 통해 내리고 짐을 찾는다. 여행이 불편했다면 티켓 에이전트에게 항의한다.</p>
</blockquote>
<p>다음 과정을 몇 가지 가능성을 추가하여 <code>수평</code> 방식으로 <code>구조화</code> 하면 아래 그림과 같다.
<img src="../Figure_1/Figure_1.22.png" alt="그림 1.22 항공 기능의 수평 계층화" />
(1) 그 계층에서 어떤 동작을 취하고 (2) 그 계층 바로 아래 계층 서비스를 이용함으로써 서비스를 제공한다. 네트워크도 이와 같으며 계층 구조는 크고 복잡한 시스템 일수록 잘 정의된 특정 부분을 논의할 수 있게 해준다. 또한 계속해서 갱신되는 복잡하고 커다란 시스템일 경우, 시스템은 다른 요소에 영향을 주지 않고 서비스 구현을 변화시킬 수 있다.</p>
<h3>프로토콜 계층화</h3>
<blockquote>
<p>네트워크 설계자는 프로토콜(프로토콜을 구현하는 네트워크 하드웨어와 소프트웨어)을 <strong>계층(layer)</strong> 으로 조직한다.
<img src="../Figure_1/Figure_1.23.png" alt="그림 1.22 인터넷 프로토콜 스택" /></p>
</blockquote>
<ul>
<li>각 프로토콜은 한 계층에 속한다.</li>
<li>한 계층이 상위 계층에 제공하는 <strong>서비스(service)</strong> 에 관심을 가지며 이것을 계층의 <strong>서비스 모델(service model)</strong> 이라고 한다.</li>
<li>각 계층은 계층 내부에서 어떤 동작을 수행하거나, 직접 하위 계층의 서비스를 사용한다.</li>
<li>프로토콜 계층은 소프트웨어, 하드웨어 또는 둘의 통합으로 구현할 수 있다.</li>
<li>$n$계층 프로토콜은 네트워크를 구성하는 종단 시스템, 패킷 스위치, 그 외에 요소 사이에 <code>분산</code>되어 있다.
<ul>
<li>각 네트워크 구성요소에는 하나의 $n$계층 프로토콜이 존재한다.</li>
</ul>
</li>
<li>프로토콜 계층화는 개념과 구조 측면에서 이점이 있다.
<ol>
<li>시스템 구성요소에 대해 논의하기 위한 구조화된 방법을 제공한다.</li>
<li>모듈화는 시스템 구성요소의 갱신을 더 쉽게 해준다.</li>
</ol>
</li>
<li>다양한 계층의 프로토콜을 모두 합하여 <strong>프로토콜 스택(protocol stack)</strong> 이라고 하며, 5개 계층으로 구성된다. → 우리는 <strong>톱다운 방식(top-down approach)</strong> 을 채택할 것이다.</li>
</ul>
<h3>애플리케이션 계층</h3>
<blockquote>
<p>네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳</p>
</blockquote>
<ul>
<li>HTTP(웹 문서 요청과 전송 제공), SMTP(전자메일 전송 제공), FTP(두 종단 시스템 간의 파일 전송 제공) 같은 많은 프로토콜을 포함한다.
<ul>
<li>예를 들어 www.ietf.org 같은 이름을 32비트 네트워크 주소로 변환하는 네트워크 기능이 있다(이것을 도메인 네임 서버(domain name server, DNS)가 돕는다).</li>
</ul>
</li>
<li>여러 종단 시스템에 분산되어 있어서 한 종단 시스템에 있는 애플리케이션이 다른 종단 시스템에 있는 애플리케이션과 정보 패킷을 교환하는 데 이 프로토콜을 사용한다.
<ul>
<li>이 정보 패킷을 <strong>메시지(message)</strong> 라고 부른다.</li>
</ul>
</li>
</ul>
<h3>트랜스포트 계층</h3>
<blockquote>
<p>클라이언트와 서버 간에 애플리케이션 계층 메시지를 전송하는 서비스를 제공하는 곳</p>
</blockquote>
<ul>
<li>TCP, UDP 두 가지 프로토콜이 있으며 이들은 애플리케이션 계층 메시지를 전달한다.</li>
<li>TCP
<ol>
<li>애플리케이션에게 연결지향형 서비스를 제공한다.
<ul>
<li>목적지로의 애플리케이션 계층 메시지 전달 보장과 흐름 제어(송신자/수신자의 속도 일치)를 포함한다.</li>
</ul>
</li>
<li>긴 메시지를 짧은 메시지로 나누고 혼잡 제어 기능을 제공하여 네트워크가 혼잡할 때 출발지의 전송률을 줄이게 한다.</li>
</ol>
</li>
<li>UDP
<ol>
<li>애플리케이션애 비연결형 서비스를 제공한다.
<ul>
<li>신뢰성, 흐름 제어, 혼잡 제어를 제공하지 않는 아주 간단한 서비스다.</li>
</ul>
</li>
</ol>
</li>
<li>트랜스포트 계층 패킷을 <strong>세그먼트(segment)</strong> 라고 한다.</li>
</ul>
<h3>네트워크 계층</h3>
<blockquote>
<p>한 호스트에서 다른 호스트로 패킷을 라우팅하는 곳</p>
</blockquote>
<ul>
<li>네트워크 계층의 패킷을 <strong>데이터그램(datagram)</strong> 이라고 한다.</li>
<li>출발지 호스트에서 인터넷 트랜스포트 계층 프로토콜(TCP 또는 UDP)은 트랜스포트 계층 세그먼트와 목적지 주소를 네트워크 계층으로 전달한다. 네트워크 계층은 목적지 호스트의 트랜스포트 계층으로 세그먼트를 운반하는 서비스를 제공한다.</li>
<li>오직 하나의 IP 프로토콜이 있고 네트워크 계층을 가진 모든 인터넷 요소는 IP 프로토콜을 수행해야만 한다.
<ul>
<li>IP 데이터그램의 필드를 정의하며 종단 시스템과 라우터가 이 필드에 어떻게 동작하는지를 정의하는 프로토콜</li>
</ul>
</li>
<li>출발지와 목적지 사이에서 데이터그램이 이동하는 경로를 결정하는 라우팅 프로토콜을 포함한다.</li>
</ul>
<h3>링크 계층</h3>
<blockquote>
<p>종단 간 경로 상의 한 노드(호스트 혹은 패킷 스위치)에서 다른 노드로 패킷(데이터그램)을 전달하는 곳</p>
</blockquote>
<ul>
<li>링크 계층 패킷을 <strong>프레임(frame)</strong> 이라고 한다.</li>
<li>링크 계층에서 제공하는 서비스는 그 링크에서 채용된 특정 링크 계층 프로토콜에 의해 결정된다.
<ul>
<li>이더넷, 와이파이, 케이블 접속 네트워크의 DOCSIS 프로토콜 등</li>
</ul>
</li>
<li>네트워크 계층은 각기 다른 링크 계층 프로토콜로부터 다른 서비스를 제공받을 것이다.</li>
</ul>
<h3>물리 계층</h3>
<blockquote>
<p>프레임 내부의 각 비트를 한 노드에서 다음 노드로 이동시키는 기능을 하는 곳</p>
</blockquote>
<ul>
<li>이 계층의 프로토콜들은 링크에 의존하고 더 나아가 링크의 실제 전송 매체에 의존한다.
<ul>
<li>예: 꼬임쌍선, 단일 모드 광케이블</li>
</ul>
</li>
<li>이더넷은 여러 가지 물리 계층 프로토콜을 갖고 있다.
<ul>
<li>예: 꼬임쌍선용, 동축케이블용, 광케이블용 등
<ul>
<li>각각의 경우에 비트는 다른 방식으로 링크 반대편으로 이동된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>1.5.2 캡슐화</h2>
<hr />
<p><img src="../Figure_1/Figure_1.24.png" alt="그림 1.24 호스트, 라우터, 링크 계층 스위치" /></p>
<ul>
<li>그림 1.24는 송신 종단 시스템의 프로토콜 스택 아래로 데이터를 보내며 중간의 링크 계층 스위치와 라우터의 프로토콜 스택을 위아래로 거치고 수신하는 종단 시스템의 프로토콜 스택 상위로 보내는 물리적 경로를 보여준다.
<ul>
<li>라우터와 링크 계층 스위치는 둘 다 패킷 교환기다.</li>
<li>종단 시스템과 비슷하게 라우터와 링크 계층 스위치는 네트워킹 하드웨어와 소프트웨어를 계층으로 구성하지만, 프로토콜 스택의 모든 계층을 구현하지는 않으며 일반적으로 하위계층을 구현한다.
<ul>
<li>링크 계층 스위치는 1, 2 계층을 구현하고 라우터는 1~3 계층을 구현한다.</li>
<li>예를 들어, 인터넷 라우터들이 IP 프로토콜(3계층 프로토콜)을 구현할 수는 있지만 링크 계층 스위치는 그럴 수 없다.</li>
</ul>
</li>
<li>링크 계층 스위치는 IP 주소를 인식하지 못하지만 이더넷 주소 같은 2계층 주소를 인식할 수 있다.</li>
<li>호스트는 다섯 계층 모두를 구현한다.
<ul>
<li>인터넷 구조가 네트워크의 ’가장자리’에서 복잡성을 유지한다는 관점과 일치한다.</li>
</ul>
</li>
</ul>
</li>
<li>또한 그림 1.24는 <strong>캡슐화(encapsulation)</strong> 개념의 중요성을 보여준다.
<ul>
<li><strong>애플리케이션 계층 메시지(application layer message)</strong>: 송신 호스트에서 이것을 트랜스포트 계층으로 보내고 가장 간단한 경우에 여기서 메시지에 수신 측 트랜스포트 계층에서 사용될 추가 정보(트랜스포트 계층 헤더 정보라고 하며, 위 그림에서는 $H_t$)를 더한다.</li>
<li><strong>트랜스포트 계층 세그먼트(transport-layer segment)</strong>: 위 과정(애플리케이션 계층 메시지 + 트랜스포트 계층 헤더 정보)을 거친 것. 추가된 정보는 메시지를 적절한 애플리케이션으로 보내도록 하는 정보와 메시지들의 비트들이 변경되었는지 수신지가 결정하게 하는 오류 검출 비트를 포함한다.</li>
<li><strong>네트워크 계층 데이터그램(network-layer datagram)</strong>: 트랜스포트 계층 세그먼트 + 종단 시스템 주소와 동일한 헤더 정보(위 그림에서는 $H_n$).</li>
<li><strong>링크 계층 프레임(link-layer frame)</strong>: 네트워크 계층 데이터그램 + 링크 계층의 헤더 정보(위 그림에서는 $H_l$)</li>
</ul>
</li>
<li>따라서 각 계층에서 패킷은 헤더 필드와 <strong>페이로드 필드(payload field)</strong> 라는 두 가지 형태의 필드를 갖는다.
<ul>
<li>페이로드는 일반적으로 그 계층 상위로부터의 패킷이다.</li>
</ul>
</li>
<li>이것은 공중 우편 서비스를 통해 한 기업의 지부에서 다른 지부로 사내 메모를 보내는 것과 유사하다.
<ol>
<li>한 지부에 있는 앨리스가 다른 지부에 있는 밥에게 메모를 보내고자 한다고 가정하자.
<ul>
<li>이 <code>메모</code>는 <code>애플리케이션 계층 메시지</code>와 유사하다.</li>
</ul>
</li>
<li>앨리스는 밥의 이름과 부서를 적은 사내 봉투에 메모를 넣는다.
<ul>
<li><code>사내 봉투</code>는 <code>트랜스포트 계층 세그먼트</code>와 유사하다. 이것은 헤더 정보(밥의 이름과 부서 번호)를 포함하고 애플리케이션 계층 메시지(메모)를 캠슐화한다.</li>
</ul>
</li>
<li>송신 지부 메일룸은 사내 봉투를 수신하면 이 사내 봉투를 다른 봉투, 즉 공중 우편 서비스를 통해 보내기에 적당한 봉투에 넣는다. 또한 송신 메일룸은 우편 봉투에 송신과 수신 지부의 우편주소를 적는다.
<ul>
<li>여기서 <code>우편 봉투</code>는 <code>데이터그램</code>과 유사하다. 이것은 원래의 메시지(메모)를 캡술화하는 트랜스포트 계층 세그먼트(사내 봉투)를 캡슐화한다. 우편 서비스는 우편 봉투를 수신 지부 메일룸으로 전달한다.</li>
</ul>
</li>
<li>여기서 캡슐화의 반대 과정이 시작된다. 메일룸은 사내 봉투를 꺼내서 밥에게 전달하고 밥은 사내 봉투에서 메모를 꺼낸다.</li>
</ol>
</li>
<li>캡슐화 과정은 위에서 기술한 것보다 더 복잡할 수 있다.
<ul>
<li>예를 들어, 큰 메시지는 여러 개의 트랜스포트 계층 세그먼트로 분할될 수 있다. 그리고 나서 수신 측에서 각 세그먼트는 분할된 데이터그램들로 재구성되어야 한다.</li>
</ul>
</li>
</ul>

            </div>
        </div>
    </div>

    <div class="floating-top-button" id="topButton">↑</div>

    <footer class="footer">
        <p>&copy; 2024 Urim Yang. Connection established.</p>
        <p>Powered by LimeDocs</p>
    </footer>

    <script>
        const topButton = document.getElementById('topButton');
        
        // 스크롤 위치에 따라 버튼 표시/숨김
        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                topButton.classList.add('visible');
            } else {
                topButton.classList.remove('visible');
            }
        });

        // 클릭 시 최상단으로 이동
        topButton.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    </script>
</body>
</html>