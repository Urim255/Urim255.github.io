<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Urim Yang's personal blog about computer science, Rust programming, and networking.">
        <link rel="icon" href="/lime_icon.png"/>
        <title>Urim Yang's Blog</title>

        <!-- MathJax CDN -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

        <script>
            MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']], // 인라인 수식 설정
                displayMath: [['$$', '$$'], ['\\[', '\\]']] // 블록 수식 설정
              }
            };
          </script>
          <script async src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
          <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
    
            body {
                font-family: 'Arial', sans-serif;
                line-height: 1.6;
                background: #f8f8f8;
                padding: 2rem;
                scroll-behavior: smooth;
            }
    
            .container {
                max-width: 1200px;
                margin: 0 auto;
            }
    
            .section-block {
                background: white;
                border-radius: 15px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.05);
                padding: 2rem;
                margin-bottom: 1.5rem;
                transition: transform 0.3s ease, box-shadow 0.3s ease;
            }

            /* 호버링 효과 추가 */
            .section-block:hover {
                transform: translateY(-5px);
                box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            }

            /* Text Section에 특별한 패딩 추가 */
            .text-content {
                padding: 0 2rem;
                max-width: 800px;
                margin: 0 auto;
                text-align: justify;
            }

            /* 첫 줄(제목)과 마지막 줄 왼쪽 정렬 */
            .text-content p:first-child,
            .text-content p:last-child {
                text-align: left;
            }
    
            /* Content Styling */
            /* Lists */
            .section-block ul,
            .section-block ol {
                padding-left: 2rem;
                margin: 1rem 0;
            }

            .section-block ul ul,
            .section-block ol ol,
            .section-block ul ol,
            .section-block ol ul {
                margin: 0.5rem 0;
            }

            /* Inline Code */
            code:not(pre code) {
                background-color: #f5f5f5;
                padding: 0.2em 0.4em;
                border-radius: 3px;
                font-family: monospace;
            }

            /* Blockquote */
            blockquote {
                border-left: 4px solid #32CD32;
                padding-left: 1rem;
                margin: 1rem 0;
                color: #666;
                background-color: #f9f9f9;
                padding: 1rem;
            }

            /* Tables */
            table {
                width: 100%;
                border-collapse: collapse;
                margin: 1rem auto;
                text-align: center;
            }

            th, td {
                border: 1px solid #ddd;
                padding: 0.8rem;
            }

            th {
                background-color: #f5f5f5;
            }

            /* Images */
            img:not(.profile-image) {
                display: block;
                max-width: 100%;
                margin: 1rem auto;
                border-radius: 5px;
            }

            /* Code Blocks */
            pre {
                background-color: #f5f5f5;
                padding: 1rem;
                border-radius: 5px;
                overflow-x: auto;
                margin: 1rem 0;
            }

            pre code {
                font-family: monospace;
                display: block;
                line-height: 1.5;
            }

            .animation-section {
                padding: 1.5rem;
                cursor: pointer;
            }
    
            .communication-container {
                position: relative;
                width: 500px;
                height: 100px;
                margin: 0 auto;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
    
            .object {
                width: 50px;
                height: 50px;
                background: #32CD32;
                border-radius: 50%;
                position: relative;
            }
    
            .object::after {
                content: '';
                position: absolute;
                top: -5px;
                left: -5px;
                right: -5px;
                bottom: -5px;
                border: 2px solid #32CD32;
                border-radius: 50%;
                opacity: 0;
                animation: pulse 2s infinite;
            }
    
            @keyframes pulse {
                0% { transform: scale(1); opacity: 0.8; }
                100% { transform: scale(1.5); opacity: 0; }
            }
    
            .signal {
                position: absolute;
                height: 2px;
                background: #32CD32;
                top: 50%;
                opacity: 0;
            }
    
            .syn { width: 40%; left: 20%; animation: sendSignal 3s infinite; }
            .syn-ack { width: 40%; right: 20%; animation: sendSignal 3s infinite 1s; }
            .ack { width: 60%; left: 20%; animation: sendSignal 3s infinite 2s; }
    
            @keyframes sendSignal {
                0% { transform: scaleX(0); opacity: 0; }
                20% { transform: scaleX(1); opacity: 1; }
                40% { transform: scaleX(1); opacity: 1; }
                60% { transform: scaleX(0); opacity: 0; }
                100% { transform: scaleX(0); opacity: 0; }
            }
    
            .site-title {
                text-align: center;
                font-size: 1.8rem;
                margin-top: 1rem;
                color: #333;
            }
    
            .profile-section {
                display: flex;
                align-items: center;
                gap: 1.5rem;
                padding: 1rem;
                max-width: 800px;
                margin: 0 auto;
                cursor: pointer;
            }
    
            .profile-image {
                width: 90px;
                height: 90px;
                border-radius: 50%;
                object-fit: cover;
                border: 3px solid #32CD32;
                flex-shrink: 0;
            }
    
            .profile-info {
                flex: 1;
                text-align: left;
            }
    
            .profile-name {
                font-size: 1.4rem;
                color: #333;
                margin-bottom: 0.3rem;
            }
    
            .profile-status {
                font-size: 0.95rem;
                color: #666;
                font-style: italic;
                line-height: 1.4;
            }
    
            .footer {
                text-align: center;
                padding: 1.5rem;
                color: #666;
                font-size: 0.9rem;
            }
    
            .footer a {
                color: #32CD32;
                text-decoration: none;
            }
    
            /* 반응형 디자인 */
            @media (max-width: 768px) {
                body {
                    padding: 1rem;
                }
    
                .section-block {
                    padding: 1.25rem;
                }

                .text-content {
                    padding: 0 1rem;
                }
    
                .communication-container {
                    width: 300px;
                    height: 70px;
                }
    
                .object {
                    width: 35px;
                    height: 35px;
                }
    
                .site-title {
                    font-size: 1.4rem;
                }
            }
    
            @media (max-width: 600px) {
                .profile-section {
                    flex-direction: column;
                    text-align: center;
                    gap: 0.8rem;
                    padding: 0.8rem;
                }
    
                .profile-info {
                    text-align: center;
                }
    
                .profile-image {
                    width: 75px;
                    height: 75px;
                }

                .text-content {
                    padding: 0 0.8rem;
                }
            }
    
            @media (max-width: 480px) {
                .communication-container {
                    width: 220px;
                    height: 50px;
                }
    
                .object {
                    width: 25px;
                    height: 25px;
                }
    
                .site-title {
                    font-size: 1.2rem;
                }
            }

            /* 플로팅 Top 버튼 스타일 */
            .floating-top-button {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 40px;
                height: 40px;
                background-color: #32CD32;
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            }

            .floating-top-button.visible {
                opacity: 1;
                visibility: visible;
            }

            .floating-top-button:hover {
                background-color: #28a428;
                transform: translateY(-3px);
            }
        </style>
    </head>
<body>
    <div class="container">
        <!-- Animation Section -->
        <a href="/" style="text-decoration: none; color: inherit;">
            <div class="section-block animation-section">
                <div class="communication-container">
                    <div class="object"></div>
                    <div class="object"></div>
                    <div class="signal syn"></div>
                    <div class="signal syn-ack"></div>
                    <div class="signal ack"></div>
                </div>
                <h1 class="site-title">Initiate, Acknowledge, Establish</h1>
            </div>
        </a>

        <!-- Profile Section -->
        <a href="mailto:email@com" style="text-decoration: none; color: inherit;">
            <div class="section-block">
                <div class="profile-section">
                    <img src="/profile.jpg" alt="Profile Image" class="profile-image">
                    <div class="profile-info">
                        <h2 class="profile-name">Urim Yang</h2>
                        <p class="profile-status">A Trailblazer Exploring Unknown Computer Network Worlds</p>
                    </div>
                </div>
            </div>
        </a>

        <!-- Text Section -->
        <div class="section-block">
            <div class="text-content" id="textContent">
                <h1>2.3 인터넷 전자메일</h1>
<hr />
<p>전자메일은 인터넷 초기부터 널리 사용되어 왔으며, 오늘날 인터넷에서 가장 중요한 애플리케이션 중 하나이다. 전자메일은 비동기적인 통신 매체로, 사용자들이 자신의 일정에 맞춰 메시지를 주고받을 수 있다. 또한, 전자메일은 분배가 쉽고, 빠르고, 저렴하며, 첨부된 메시지, 하이퍼링크, HTML 포맷 텍스트, 내장된 사진 등 강력한 기능을 제공한다.</p>
<h3>주요 구성 요소와 송수신 과정</h3>
<p><img src="../Figure_2/Figure_2.14.png" alt="그림 2.14 인터넷 전자메일 시스템의 상위 레벨 개념" /></p>
<ul>
<li><strong>사용자 에이전트 (User Agent)</strong>: 사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 해주는 도구. 
<ul>
<li>예시: Microsoft Outlook, Apple Mail, Gmail(웹 및 앱).</li>
</ul>
</li>
<li><strong>메일 서버 (Mail Server)</strong>
<ul>
<li>메시지(이메일)를 저장하고 관리하는 서버</li>
<li>송신자의 메일 서버를 거쳐 수신자의 메일 서버를 거쳐 수신자의 <strong>메일박스(mailbox)</strong> 에 저장 </li>
<li>재전송 메커니즘
<ul>
<li>수신자 서버 장애 시, 송신자 메일 서버는 <strong>메시지 큐(message queue)</strong> 에 저장</li>
<li>약 30분마다 재전송 시도</li>
<li>여러 날 시도 후 실패하면, 송신자에게 이메일로 실패 통보</li>
</ul>
</li>
</ul>
</li>
<li><strong>SMTP(Simple Mail Transfer Protocol)</strong>
<ul>
<li>인터넷 이메일 전송을 위한 애플리케이션 계층 프로토콜</li>
<li>TCP의 신뢰적인 데이터 전송 서비스 활용</li>
<li>SMTP 클라이언트-서버 구조
<ul>
<li>송신자 메일 서버 → SMTP 클라이언트로 동작 (메일 전송)</li>
<li>수신자 메일 서버 → SMTP 서버로 동작 (메일 수신)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>2.3.1 SMTP</h2>
<hr />
<p>SMTP(Simple Mail Transfer Protocol)는 RFC 5321에 정의된 인터넷 전자메일 전송 프로토콜로, 송신자의 메일 서버에서 수신자의 메일 서버로 메시지를 전달한다. 1982년에 표준화되었으며, 7비트 ASCII 형식을 사용해야 하는 제한이 있어 멀티미디어 데이터를 전송하려면 ASCII로 변환해야 하는 단점이 있다(받은 후에도 ASCII에서 원래 메시지로 변환 작업 필요). → HTTP는 전송 전에 멀티미디어 데이터를 ASCII로 변환하는 것을 요구하지 않음.</p>
<p>SMTP 작동 시나리오는 다음과 같으며, 그림 2.15에 요약되어 있다.
<img src="../Figure_2/Figure_2.15.png" alt="그림 2.15 앨리스가 밥에게 메시지를 전달" /></p>
<ol>
<li>앨리스는 전자메일 사용자 에이전트를 수행하고 밥의 전자메일 주소(예: <code>bob@someschool.edu</code>)를 제공하고, 메시지를 작성하고 사용자 에이전트에게 메시지를 보내라고 명령한다.</li>
<li>앨리스의 사용자 에이전트는 메시지를 그녀의 메일 서버에게 보내고 그곳에서 메시지는 메시지 큐에 놓인다.</li>
<li>앨리스의 메일 서버에서 동작하는 SMTP의 클라이언트 측은 메시지 큐에 있는 메시지를 본다. 밥의 메일 서버에서 수행되고 있는 SMTP 서버에게 TCP 연결(포트 번호 25)을 설정한다.</li>
<li>초기 SMTP 핸드셰이킹 이후에 SMTP 클라이언트는 앨리스의 메시지를 TCP 연결로 보낸다.</li>
<li>밥의 메일 서버 호스트에서 SMTP의 서버 측은 메시지를 수신한다. 밥의 메일 서버는 그 메시지를 밥의 메일박스에 놓는다.</li>
<li>뱝은 편한 시간에 그 메시지를 읽기 위해 사용자 에이전트를 시동한다.</li>
</ol>
<p>SMTP는 중간 서버를 거치지 않고 직접 TCP 연결을 사용하여 메시지를 전달하며, 수신자의 서버가 다운되었을 경우 송신자의 서버에서 재시도를 수행한다.</p>
<p>SMTP 클라이언트(C)와 SMTP 서버(S) 사이의 메시지 전달 과정의 예를 보면 아래와 같다.</p>
<pre><code>S: 220 hamburger.edu
C: HELO crepes.fr
S: 250 Hello crepes.fr, pleased to meet you
C: MAIL FROM: &lt;alice@crepes.fr&gt;
s: 250 alice@crepes.fr ... Sender ok
C: RCPT TO: &lt;bob@hamburger.edu&gt;
s: 250 bob@hamburger.edu ... Recipient ok
C: DATA
S: 354 Enter mail, end with &quot;.&quot; on a line by itself
C: Do you like ketchup?
C: How about pickles?
C: .
S: 250 Message accepted for delivery
C: QUIT
S: 221 hamburger.edu closing connection
</code></pre>
<p>SMTP 클라이언트는 5개 명령을 사용하였는데, 명령어 예시는 다음과 같다:</p>
<ul>
<li><code>HELO</code>: 클라이언트가 서버에게 인사</li>
<li><code>MAIL FROM</code>: 발신자 지정</li>
<li><code>RCPT TO</code>: 수신자 지정</li>
<li><code>DATA</code>: 메시지 본문 입력</li>
<li><code>QUIT</code>: 연결 종료</li>
</ul>
<p>또한 클라이언트는 하나의 점(.)으로 된 라인을 송신하며, 그것은 서버에게 메시지의 끝을 나타낸다(ASCII에서 각 메시지는 CRLF.CRLF로 끝나며, CR과 LF는 각각 ’carriage return’과 ’line feed’의 약자다).
서버는 각 명령에 응답하며, 각 응답에는 응답 코드와 영문 설명(옵션)이 있다.</p>
<p>SMTP는 지속적인 TCP 연결을 사용하여 동일한 수신 서버로 여러 메시지를 전송할 수 있다.</p>
<p>텔넷을 사용하여 SMTP 서버와 직접 대화할 수 있다.</p>
<pre><code>telnet serverName 25
</code></pre>
<p><code>serverName</code>은 원격 메일 서버의 이름이다. 이 명령을 실행하면, 여러분의 로컬 호스트와 메일 서버 사이에 TCP 연결이 설정된다.</p>
<h2>2.3.2 메일 메시지 포맷</h2>
<p>메일 메시지는 일반 우편처럼 헤더와 본문으로 구성된다. 헤더에는 송신자(<code>From:</code>), 수신자(<code>To:</code>), 제목(<code>Subject:</code>) 등의 정보를 포함하며, RFC 5322에 따라 정의된다. 헤더와 본문은 빈 줄(CRLF)로 구분된다. 헤더 정보는 SMTP 프로토콜의 명령과는 <code>다르며</code>, 메일 메시지 자체의 일부이다. SMTP를 통해 이러한 헤더가 포함된 메시지를 전송할 수 있다.</p>
<pre><code>From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.
</code></pre>
<h2>2.3.3 메일 접속 프로토콜</h2>
<hr />
<p>SMTP는 송신자의 메일 서버에서 수신자의 메일 서버로 메시지를 전달하지만, 수신자가 자신의 PC나 스마트폰에서 직접 메일을 관리하는 것은 비효율적이다. 대신, 사용자는 항상 켜져 있는 공유 메일 서버에 저장된 메일을 확인한다.
<img src="../Figure_2/Figure_2.16.png" alt="그림 2.16 전자메일 프로토콜과 통신 개체" /></p>
<h3>전자메일 메시지 경로</h3>
<ol>
<li>앨리스(발신자)의 사용자 에이전트 → SMTP/HTTP → 앨리스의 메일 서버</li>
<li>앨리스의 메일 서버 → SMTP → 밥(수신자)의 메일 서버
<ul>
<li>발신자의 메일 서버가 중계 역할을 하여 목적지 메일 서버에 도달할 수 있도록 함</li>
<li>목적지 메일 서버가 준비될 때까지 일정 주기로 재전송</li>
</ul>
</li>
</ol>
<h3>수신자가 메일을 확인하는 방법</h3>
<ul>
<li>웹 기반 메일 서비스(Gmail 등)
<ul>
<li>HTTP를 사용하여 메일 서버에 접속하여 확인</li>
<li>메일 서버는 SMTP와 HTTP 인터페이스를 지원해야 함</li>
</ul>
</li>
</ul>
<ul>
<li>메일 클라이언트(Outlook 등)
<ul>
<li><strong>인터넷 메일 접속 프로토콜 (Internet Mail Access Protocol, IMAP, RFC 3501)</strong> 사용</li>
<li>서버에 저장된 폴더를 관리하며, 메시지 이동·삭제·표시 기능 제공</li>
</ul>
</li>
</ul>
<p>SMTP는 푸시(push) 프로토콜이므로, 수신자가 메일을 가져오는 데는 적합하지 않다. 대신, HTTP 또는 IMAP을 사용하여 메일을 확인한다.</p>

            </div>
        </div>
    </div>

    <div class="floating-top-button" id="topButton">↑</div>

    <footer class="footer">
        <p>&copy; 2024 Urim Yang. Connection established.</p>
        <p>Powered by LimeDocs</p>
    </footer>

    <script>
        const topButton = document.getElementById('topButton');
        
        // 스크롤 위치에 따라 버튼 표시/숨김
        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                topButton.classList.add('visible');
            } else {
                topButton.classList.remove('visible');
            }
        });

        // 클릭 시 최상단으로 이동
        topButton.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    </script>
</body>
</html>